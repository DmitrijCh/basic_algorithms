/* Принцип работы алгоритма:
 Пройти по каждому символу в массиве, если элемет не является специальным символом поместить его в стек.
 Когда будет найден специальный символ, взять первые два числа из стека и произвести с ними нужное арифметическое действие,
согласно условию и всавить обратно в стек. Когда цикл будет пройден, условия выполнены, извлекается элемент из стека и
печатается.
 Алгоритм основан на бинарном поиске. Несмотря на то, что массив имеет сдвиг, он по прежнему остается отсортированным.
 Но у него есть две отсортированные части. Поэтому необходимо добавить проверку меньше ли крайний левый элемент
среднего элемента. Если да, значит левая половина упорядочена, а в правой есть сдвинутая часть, либо (ветвь else)
сдвинутая часть находится в левой части.
 В остальном алгоритм аналогичен стандартному бинарному поиску.
 Алгоритм корректен, так как в цикле изменяются левый и правый указатели, пока они не сойдутся. Благодаря тому, что массив
отсортирован, нет необходимости смотреть все элементы, достаточно делить массив попалам и сравнивать искомый элемент с
крайними в этом диапазоне. Сдвиг массива только добавляет одну проверку в алгоритм.
 */

/* Временная сложность алгоритма: O(NlogN)
 Так как на каждом шаге алгоритма размер массива сокращается вдвое, то потребуется сделать logN шагов.
*/ 
 
/* Пространственная сложность алгоритма: O(n)
 Во время выполнения не создается дополнительных структур данных кроме исходного массива.
 */ 

public class Solution {
    public static int brokenSearch(int[] arr, int k) {
        int leftElement = 0;
        int rightElement = arr.length - 1;
        int middleElement;
        while (leftElement <= rightElement) {
            middleElement = (leftElement + rightElement) / 2;
            if (arr[middleElement] == k) {
                return middleElement;
            }
            if (arr[leftElement] <= arr[middleElement]) {
                if (arr[leftElement] <= k && arr[middleElement] >= k) {
                    rightElement = middleElement - 1;
                } else {
                    leftElement = middleElement + 1;
                }
            }
            if(arr[rightElement] >= arr[middleElement]) {
                if (arr[rightElement] >= k && arr[middleElement] >= k ) {
                    rightElement = middleElement - 1;
                } else {
                    leftElement = middleElement + 1;
                }
            }
        }
        return -1;
    }

    private static void test() {
        int[] arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
        assert 6 == brokenSearch(arr, 5);
    }
} 